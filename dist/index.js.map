{"version":3,"sources":["webpack://deltav-quick-surface/webpack/universalModuleDefinition","webpack://deltav-quick-surface/webpack/bootstrap","webpack://deltav-quick-surface/external \"deltav\"","webpack://deltav-quick-surface/./src/types.ts","webpack://deltav-quick-surface/./src/surface/quick-surface.ts","webpack://deltav-quick-surface/./src/index.ts","webpack://deltav-quick-surface/./src/constants.ts","webpack://deltav-quick-surface/./src/surface/index.ts","webpack://deltav-quick-surface/./src/util/delete-prop.ts","webpack://deltav-quick-surface/./src/util/get-prop.ts","webpack://deltav-quick-surface/./src/util/lookup-values.ts","webpack://deltav-quick-surface/./src/util/loop-inheritance.ts","webpack://deltav-quick-surface/./src/util/map-lookup-values.ts","webpack://deltav-quick-surface/./src/util/queued-handler.ts","webpack://deltav-quick-surface/./src/util/set-prop.ts","webpack://deltav-quick-surface/./src/config.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","info","QuickSurface","QueuedHandler"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"deltav\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"deltav\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"deltav-quick-surface\"] = factory(require(\"deltav\"));\n\telse\n\t\troot[\"deltav-quick-surface\"] = factory(root[\"deltav\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\n  AbsolutePosition,\n  Camera,\n  EventManager,\n  ILayerConstructionClass,\n  ILayerProps,\n  ILayerRef,\n  Instance,\n  InstanceProvider,\n  IPickInfo,\n  IViewConstructionClass,\n  IViewProps,\n  LayerInitializer,\n  Lookup,\n} from \"deltav\";\n\nexport type DeepMap<T, S, D> = {\n  [K in keyof T]: T[K] extends S ? D : DeepMap<T[K], S, D>;\n};\n\n/**\n * A simple and quick definition of a view.\n */\nexport type QuickView = {\n  viewport: AbsolutePosition;\n  camera?: Camera;\n  manager?: EventManager | EventManager[];\n};\n\n/**\n * A setting defining a type of layer class along with defaults to apply to that layer class upon construction.\n */\nexport type LayerDefaults = {\n  type: ILayerConstructionClass<any, any>;\n  defaults(instance: Instance): ILayerProps<any>;\n};\n\n/**\n * A setting defining a type of view class along with defaults to apply to that view class upon construction.\n */\nexport type ViewDefaults = {\n  type: IViewConstructionClass<any>;\n  defaults: IViewProps;\n};\n\n/**\n * A base type for all handler types\n */\nexport type InstanceHandler = (info: IPickInfo<Instance>) => void;\n\n/**\n * Typeguard for InstanceHandler lookups\n */\nexport function isInstanceHandler(\n  val: Lookup<InstanceHandler> | InstanceHandler\n): val is InstanceHandler {\n  return typeof val === \"function\";\n}\n\n/**\n * Typeguard for QuickView options\n */\nexport function isQuickView(\n  val: Lookup<QuickView> | QuickView\n): val is QuickView {\n  return Boolean(val && val.viewport);\n}\n\n/**\n * Typeguard for deltav LayerInitializers\n */\nexport function isLayerInitializer(val?: any): val is LayerInitializer {\n  return val !== void 0 && Boolean(val.key !== void 0 && val.init);\n}\n\n/**\n * Typeguard for deltav ILayerRefs\n */\nexport function isLayerRef(\n  val?: Lookup<ILayerRef | undefined> | ILayerRef\n): val is ILayerRef {\n  return val !== void 0 && val.easing !== void 0;\n}\n\n/**\n * Typeguard for determining lookup value being a single or list of Instance\n */\nexport function isInstanceType(\n  val?: Instance[] | Lookup<Instance[]>\n): val is Instance[] {\n  return Boolean(val && Array.isArray(val));\n}\n\n/**\n * Typeguard for filtering InstanceProvider look ups to determine if the element is a lookup or a provider\n */\nexport function isInstanceProvider<T extends Instance>(\n  val: InstanceProvider<T> | Lookup<InstanceProvider<T>>\n): val is InstanceProvider<T> {\n  return val instanceof InstanceProvider;\n}\n","import {\n  BaseResourceOptions,\n  BasicCamera2DController,\n  BasicSurface,\n  BasicSurfaceSceneOptions,\n  Camera,\n  Camera2D,\n  Color,\n  createAtlas,\n  createFont,\n  createLayer,\n  createView,\n  EventManager,\n  FontMapGlyphType,\n  IFontResourceOptions,\n  ILayerConstructionClass,\n  ILayerProps,\n  ILayerRef,\n  IMousePickInfo,\n  Instance,\n  InstanceProvider,\n  IPickInfo,\n  isDefined,\n  ISurfaceOptions,\n  ITouchPickInfo,\n  IViewProps,\n  Layer,\n  LayerInitializer,\n  Lookup,\n  onAnimationLoop,\n  PickType,\n  preloadNumber,\n  PromiseResolver,\n  ReferenceCamera2D,\n  stopAnimationLoop,\n  TextureSize,\n  ViewInitializer,\n  WebGLStat,\n} from \"deltav\";\nimport {\n  DeepMap,\n  isInstanceHandler,\n  isInstanceType,\n  isLayerInitializer,\n  isLayerRef,\n  isQuickView,\n  LayerDefaults,\n  QuickView,\n  ViewDefaults,\n} from \"../types\";\nimport { deleteProp } from \"../util/delete-prop\";\nimport { getProp } from \"../util/get-prop\";\nimport { lookupValues } from \"../util/lookup-values\";\nimport { loopInheritance } from \"../util/loop-inheritance\";\nimport { mapLookupValues } from \"../util/map-lookup-values\";\nimport { QueuedHandler } from \"../util/queued-handler\";\nimport { setProp } from \"../util/set-prop\";\n\n/**\n * Makes a quickview object and makes it identifiablewithin lookups.\n */\nexport function view(options: QuickView): QuickView {\n  return options;\n}\n\n/** Specifies all of the mouse handler specific properties of cusomtizing a QuickView */\nexport interface IQuickSurfaceMouseHandlers {\n  /**\n   * Specify mouse events for groups of instances.\n   */\n  onMouseOver?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n  onMouseOut?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n  onMouseClick?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n  onMouseDown?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n  onMouseUp?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n  onMouseUpOutside?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n  onMouseMove?: Lookup<(info: IMousePickInfo<Instance>) => void>;\n}\n\n/** Specifies all of the touch handler specific properties of cusomtizing a QuickView */\nexport interface IQuickSurfaceTouchHandlers {\n  /**\n   * Specify touch events for groups of instances\n   */\n  onTap?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchAllEnd?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchAllOut?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchDown?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchUp?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchUpOutside?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchOver?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchMove?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n  onTouchOut?: Lookup<(info: ITouchPickInfo<Instance>) => void>;\n}\n\n/**\n * These are the options needed to get a quick surface rolling. At minimum the quick surface will only need a container\n * and some data. The configuration goes up from there.\n */\nexport interface IQuickSurface<T extends Lookup<Instance[]>>\n  extends IQuickSurfaceMouseHandlers,\n    IQuickSurfaceTouchHandlers {\n  /** Sets the background color of the surface. Default is transparent. */\n  background?: Color;\n  /** The container to render the surface within */\n  container: HTMLElement;\n  /** The instances to render in the surface. */\n  data?: T;\n  /**\n   * If this is provided, this will override any font resources auto calculated for ALL of the items injected into the\n   * QuickSurface. Use QuickSurface.layerResourceMap if you want to manipulate the surface to use multiple font styles.\n   */\n  font?: IFontResourceOptions;\n  /**\n   * Rendering options that are passed to the Surface directly. Some sane defaults are selected if this is not specified\n   */\n  rendererOptions?: ISurfaceOptions[\"rendererOptions\"];\n  /**\n   * If desired: this allows you to group your data into various views on the canvas. Simply use a key identifier that\n   * is the same in your data to lump all data elements into the same view box. You then specify the view box where\n   * the data should be rendered.\n   *\n   * eg: if you have data structured like:\n   *\n   * data = { test: { test1: [...data], test2: [...data] }, foo: [...data]}\n   *\n   * you can render all elements under test in it's own viewbox by:\n   *\n   * views = { test: { viewport: { left: 0, right: '50%', bottom: '50%', top: 0 }} }\n   *\n   * A view can also specify a custom camera and a custom event manager if desired. Otherwise, a shared camera and a\n   * BasicEventManager2D is used by default.\n   */\n  views?: Lookup<QuickView>;\n  /**\n   * This callback executes when no webgl context is available. This can be used to trigger a response to show an\n   * alternative graphic for the\n   */\n  onNoWebGL?(): void;\n}\n\n/**\n * The internal configuration of the Quick Surface options as is stored on the Quick Surface itself.\n */\ninterface IQuickSurfaceInternal<T extends Lookup<Instance[]>>\n  extends IQuickSurface<T> {\n  /** The background of the surface */\n  background: Color;\n}\n\n/**\n * This is an abstraction of the DeltaV surface system to make an even easier route to getting some default Layer's\n * and Instances up and running with less configuration. This is not intended to fully replace BasicSurface or Surface\n * as it is NOT a pipeline control.\n *\n * This Surface essentially lets you focus on top level instances rather than worry about any process necessary to\n * render the instances.\n */\nexport class QuickSurface<TLookup extends Lookup<Instance[]>> {\n  /**\n   * DANGER: Advanced use only. A list of the resources that will be available. There will be at least a font and image\n   * resource available. The property keys to the resource is the key of the resource.\n   */\n  static defaultResources: Lookup<BaseResourceOptions> = {\n    defaultAtlas: createAtlas({\n      height: Math.min(WebGLStat.MAX_TEXTURE_SIZE, TextureSize._4096),\n      width: Math.min(WebGLStat.MAX_TEXTURE_SIZE, TextureSize._4096),\n    }),\n    defaultFont: createFont({\n      fontSource: {\n        errorGlyph: \"\",\n        family: \"Verdana\",\n        size: 64,\n        weight: 400,\n        localKerningCache: false,\n        type: FontMapGlyphType.BITMAP,\n        preload: preloadNumber(),\n      },\n      dynamic: true,\n      fontMapSize: [\n        Math.min(WebGLStat.MAX_TEXTURE_SIZE, TextureSize._4096),\n        Math.min(WebGLStat.MAX_TEXTURE_SIZE, TextureSize._4096),\n      ],\n    }),\n  };\n  /**\n   * DANGER: Advanced use only. Associate a layer type to a resource it should be using as well as provide the prop key\n   * to apply the resource name to.\n   */\n  static layerResourceMap = new Map<\n    ILayerConstructionClass<any, any>,\n    { [key: string]: string }\n  >();\n  /**\n   * DANGER: Advanced use only. This is merely a way to map instance classes to the layer type needed to render the\n   * instance.\n   */\n  static instanceLayerMap = new Map<any, LayerDefaults>();\n  /**\n   * DANGER: Advanced use only. This is merely a way to map instance classes to the view type needed to render the\n   * instance's expected layer type correctly.\n   */\n  static layerViewMap = new Map<\n    ILayerConstructionClass<any, any>,\n    ViewDefaults\n  >();\n  /**\n   * DANGER: Advanced use only. This is merely a way to map Camera class types to a valid reference camera type so the\n   * camera can be properly shared amongst all views if it gets used multiple times.\n   */\n  static cameraReferenceMap = new Map<Function, (cam: Camera) => Camera>();\n\n  /** This stores the raw Surface that we are abstracting with this class */\n  base: BasicSurface<this[\"data\"], any, any, any>;\n  /** This is the DOM canvas we are actually rendering to */\n  context: HTMLCanvasElement;\n  /** This is the mapped data object produced from the input data. This is a mapping of all providers. */\n  data: DeepMap<TLookup, Instance[], InstanceProvider<Instance>>;\n  /** This is all of the refs generated for the layers that are created allowing for deeper introspection. */\n  refs: DeepMap<TLookup, Instance[], ILayerRef>;\n\n  /** The default camera used for a view if none is specific */\n  private defaultCamera = new Camera2D();\n  /** A simple default controller for managing the default camera of the view */\n  private defaultManager = new BasicCamera2DController({\n    camera: this.defaultCamera,\n    ignoreCoverViews: true,\n    startView: [\"default-view.default-view\"],\n  });\n  /** These are the event managers discovered while building the surface */\n  private eventManagers: Lookup<EventManager> = {};\n  /** This is the loop id for our event processor */\n  private eventProcessingLoopId: Promise<number>;\n  /** These are the layers we produce to match the data format input */\n  private layers: DeepMap<\n    TLookup,\n    Instance | Instance[],\n    ReturnType<typeof createLayer>\n  >;\n  /** Contains all of the process queues for all mouse events */\n  private mouseQueuedHandlers: QueuedHandler[] = [];\n  /** These are the options that built this container */\n  private options: IQuickSurfaceInternal<TLookup>;\n  /** These are the scenes generated for the Basic Surface as discovered by the input data */\n  private scenes: Lookup<BasicSurfaceSceneOptions>;\n  /** Contains all of the process queues for all touch events */\n  private touchQueuedHandlers: QueuedHandler[] = [];\n\n  /** A promise that can be used to wait for readiness of the surface. */\n  get ready() {\n    return this._ready.promise;\n  }\n  private _ready = new PromiseResolver<void>();\n\n  /**\n   * Constructor of the surface. Takes in the Quick Surface options to configure the instance.\n   */\n  constructor(options: IQuickSurface<TLookup>) {\n    // Hang onto the options from the input so we can keep necessary settings.\n    this.options = Object.assign(\n      {\n        background: [0, 0, 0, 0],\n      },\n      options\n    );\n    // Start up the view with all of the new options.\n    this.init();\n  }\n\n  /**\n   * This creates the event handler queues that will handle the\n   */\n  private createEventHandlerQueues() {\n    // Make a list of all event names we will process\n    const mouseHandlerNames: (keyof IQuickSurfaceMouseHandlers)[] = [\n      \"onMouseClick\",\n      \"onMouseDown\",\n      \"onMouseMove\",\n      \"onMouseOut\",\n      \"onMouseOver\",\n      \"onMouseUp\",\n      \"onMouseUpOutside\",\n    ];\n\n    const touchHandlerNames: (keyof IQuickSurfaceTouchHandlers)[] = [\n      \"onTap\",\n      \"onTouchAllEnd\",\n      \"onTouchAllOut\",\n      \"onTouchDown\",\n      \"onTouchMove\",\n      \"onTouchOut\",\n      \"onTouchOut\",\n      \"onTouchOver\",\n      \"onTouchUp\",\n      \"onTouchUpOutside\",\n    ];\n\n    // We convert each handler group into a handler that queues and aggregates it's information\n    // Mouse and touch events differ in their structure, so we aggregate each separately.\n    // First the mouse events.\n    mouseHandlerNames.forEach((handlerName) => {\n      // See if any of the named handlers exists\n      const handlerLookup = this.options[handlerName];\n      if (!handlerLookup) return;\n\n      // Since we have potential handlers for the handler name, we do a lookup through the object to find handlers\n      // associated with keys so we can apply a Queued Handler to the layer that associates with the handler that is\n      // specified\n      mapLookupValues(\n        \"Handlers\",\n        isInstanceHandler,\n        handlerLookup,\n        (key, instanceHandler) => {\n          // At this key point, we create a process queue to handle all of the mouse events for any layer under this\n          // key position\n          const queuedHandler = new QueuedHandler(instanceHandler);\n\n          // We aggregate all layer initializers beneath this key position and apply the appropriate handler to the\n          // layer initializer from this QueuedHandler so the layer's events will be aggregated properly.\n          const initsForKey = getProp(this.layers, key);\n          if (!initsForKey) return;\n          let layerInits: LayerInitializer[];\n\n          if (isLayerInitializer(initsForKey)) {\n            layerInits = [initsForKey];\n          } else {\n            layerInits = lookupValues(isLayerInitializer, initsForKey);\n          }\n\n          // Now that we have all layer initializers under the given key, we can apply the necessary handler to the\n          // initializer so the layer will output those events.\n          layerInits.forEach((init) => {\n            // Ensure a pick mode is established for the layer.\n            init.init[1].picking = PickType.SINGLE;\n            // Create a handler for the layer\n            init.init[1][handlerName] = queuedHandler.createHandler();\n          });\n\n          // Add the handler to our list of queued handlers\n          this.mouseQueuedHandlers.push(queuedHandler);\n        }\n      );\n    });\n\n    // Next the touch events.\n    touchHandlerNames.forEach((handlerName) => {\n      // See if any of the named handlers exists\n      const handlerLookup = this.options[handlerName];\n      if (!handlerLookup) return;\n\n      // Since we have potential handlers for the handler name, we do a lookup through the object to find handlers\n      // associated with keys so we can apply a Queued Handler to the layer that associates with the handler that is\n      // specified\n      mapLookupValues(\n        \"Handlers\",\n        isInstanceHandler,\n        handlerLookup,\n        (key, instanceHandler) => {\n          // At this key point, we create a process queue to handle all of the mouse events for any layer under this\n          // key position\n          const queuedHandler = new QueuedHandler(instanceHandler);\n\n          // We aggregate all layer initializers beneath this key position and apply the appropriate handler to the\n          // layer initializer from this QueuedHandler so the layer's events will be aggregated properly.\n          const initsForKey = getProp(this.layers, key);\n          if (!initsForKey) return;\n          let layerInits: LayerInitializer[];\n\n          if (isLayerInitializer(initsForKey)) {\n            layerInits = [initsForKey];\n          } else {\n            layerInits = lookupValues(isLayerInitializer, initsForKey);\n          }\n\n          // Now that we have all layer initializers under the given key, we can apply the necessary handler to the\n          // initializer so the layer will output those events.\n          layerInits.forEach((init) => {\n            // Ensure a pick mode is established for the layer.\n            init.init[1].picking = PickType.SINGLE;\n            // Create a handler for the layer\n            init.init[1][handlerName] = queuedHandler.createHandler();\n          });\n\n          // Add the handler to our list of queued handlers\n          this.touchQueuedHandlers.push(queuedHandler);\n        }\n      );\n    });\n\n    // After the queued handlers have been established, we can now create a processing loop that will take the events\n    // and process them down to a single event to call as the feedback\n    if (this.eventProcessingLoopId) {\n      stopAnimationLoop(this.eventProcessingLoopId);\n    }\n\n    this.eventProcessingLoopId = onAnimationLoop(this.handleEvents);\n  }\n\n  /**\n   * Generates the layers that will be needed to render the data.\n   */\n  private createLayerInitializer<T extends Instance>(\n    key: string[],\n    provider: InstanceProvider<T>,\n    instances: Instance[]\n  ) {\n    // We retrieve a single instance associated with the layer so we can pick out which layer is mapped to the\n    // instance type.\n    if (isInstanceType(instances)) {\n      const instance = instances[0];\n      if (!instance) return;\n      let layerClass: ILayerConstructionClass<any, any> | undefined;\n      let props: ILayerProps<any> | undefined;\n\n      // Examine our instances inheritance chain to find a mapped layer type\n      loopInheritance(instance, (baseClass) => {\n        const base = QuickSurface.instanceLayerMap.get(baseClass);\n\n        if (base) {\n          layerClass = base.type;\n          props = base.defaults(instance);\n          return true;\n        }\n\n        return;\n      });\n\n      // If we found a valid mapped Layer for the instance type, then we can create the layer and apply the provider\n      // generated for the layer.\n      if (layerClass && props) {\n        // Check for a resource specification for the layer type\n        let resource = QuickSurface.layerResourceMap.get(layerClass);\n\n        // If no resource configuration for the exact layer is found, look up the inheritance chain of the layer for\n        // base layer registrations.\n        if (!resource) {\n          loopInheritance(layerClass, (baseClass) => {\n            resource = QuickSurface.layerResourceMap.get(baseClass as any);\n          });\n        }\n\n        // Make a ref to apply to the layer so we can properly analyze deeper information the layer may provide.\n        const ref = Layer.createRef();\n\n        const layer = createLayer(layerClass, {\n          // Set the default properties of the layer as specified from the configuration.\n          ...props,\n          // Ensure the key of the layer is the layer's property key chain.\n          key: key.join(\".\"),\n          // Layer will be tied to the data provider specified\n          data: provider,\n          // Apply the generated ref for the layer for later inspection\n          ref,\n          // The resource specification should apply to the layer if it is present\n          ...resource,\n        });\n\n        // Make our layer object have a similar property key chain as the key chain found for the data.\n        setProp(this.layers, layer, key);\n        // Make our refs mirror the layers property generated\n        setProp(this.refs, ref, key);\n\n        return layer;\n      } else {\n        console.warn(\n          \"Could not find a suitable layer for the provided instances.\"\n        );\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * This parses the data input and establishes the provider structure for the surface\n   */\n  private createProvidersAndLayers() {\n    // Get the initial input data for the surface to render and provide providers for.\n    const data = this.options.data;\n    if (!data) return;\n\n    // We delete the reference to the data internally so we don't hold onto any data structures that organize the data\n    // as they will no longer be needed for this context and are a waste of memory once they are within our providers.\n    delete this.options.data;\n    // Make sure we have an initial empty layerobject to work with\n    this.layers = {} as any;\n    this.refs = {} as any;\n\n    const providers = mapLookupValues(\n      \"providers\",\n      isInstanceType,\n      data,\n      (key, instances: Instance[]) => {\n        // Make sure we handle any input as a list\n        if (!Array.isArray(instances)) instances = [instances];\n        // Make a provider for this source\n        const provider = new InstanceProvider();\n\n        // Add all of the instances found for the key detected\n        for (let i = 0, iMax = instances.length; i < iMax; ++i) {\n          const instance = instances[i];\n          provider.add(instance);\n        }\n\n        // Now that a provider is created we must generate a layer for the key as well\n        this.createLayerInitializer(key, provider, instances);\n\n        return provider;\n      }\n    );\n\n    this.data = providers;\n  }\n\n  /**\n   * This takes the information in the views and groups the data providers and layers into the scenes they will be a\n   * part of.\n   */\n  private createScenesAndViews() {\n    const views = this.options.views;\n    const eventManagers: EventManager[] = [this.defaultManager];\n    let viewsAndLayers: ReturnType<\n      QuickSurface<TLookup>[\"createViewInitializers\"]\n    > = [];\n\n    // Make the default view under which all layers NOT grouped under a declared view will be placed.\n    const defaultView: QuickView = {\n      viewport: { left: 0, right: 0, bottom: 0, top: 0 },\n      camera: this.defaultCamera,\n      manager: this.defaultManager,\n    };\n    // Make a deep copy of the layers configuration for analyzing.\n    const layers: Lookup<LayerInitializer | undefined> = {} as any;\n    mapLookupValues(\"views\", isLayerInitializer, this.layers, (keys, value) => {\n      setProp(layers, value, keys);\n    });\n\n    // If we have views, we group up layers beneath the indicated view\n    if (views) {\n      // Storage for the layer items to be deleted as layers are grouped under a view\n      const toRemove: string[][] = [];\n\n      // Look for views available. If a view is present, we gather all of the Layers beneath the reference key.\n      mapLookupValues(\"views\", isQuickView, views, (keys, value) => {\n        // Get the lookup for the layers that matches the view's key\n        const subLayerLookup = getProp(layers, keys);\n        if (!subLayerLookup) return;\n\n        // If the key points to a single layer initializer, then we have a view for a single layer\n        if (isLayerInitializer(subLayerLookup)) {\n          // Generate our view initializer for this view\n          const viewInit = this.createViewInitializers(\n            keys,\n            [subLayerLookup],\n            value\n          );\n          // We need to gather all of the found views and layers\n          viewsAndLayers = viewsAndLayers.concat(viewInit);\n        } else {\n          // Retrieve all layers beneath the given key\n          const layersForView = lookupValues(\n            isLayerInitializer,\n            subLayerLookup\n          );\n\n          // Generate our view initializer for this view\n          const viewInits = this.createViewInitializers(\n            keys,\n            layersForView,\n            value\n          );\n          // We need to gather all of the found views and layers\n          viewsAndLayers = viewsAndLayers.concat(viewInits);\n        }\n\n        // Now remove those keys from the layers object\n        toRemove.push(keys);\n\n        // Now let's add the managers the view's specify\n        // NOTE: We will NOT need to add cameras to the basic surface. Cameras at the Surface level are only added to\n        // the view, the BasicSurface needs them for convenience patterns.\n        if (value.manager) {\n          if (Array.isArray(value.manager)) {\n            eventManagers.push(...value.manager);\n          } else {\n            eventManagers.push(value.manager);\n          }\n        }\n      });\n\n      // Perform the removals now that we're outside iterating the object\n      toRemove.forEach((keys) => deleteProp(layers, keys));\n    }\n\n    // At this point, all remaining layers will be grouped underneath the main default view\n    const layersForDefaultView = lookupValues(isLayerInitializer, layers);\n\n    // Generate our view initializer for this view\n    const viewInits = this.createViewInitializers(\n      [\"default-view\"],\n      layersForDefaultView,\n      defaultView\n    );\n    // We need to gather all of the found views and layers and play them at the beginning of our list\n    viewsAndLayers = viewInits.concat(viewsAndLayers);\n\n    // This is the scenes that will be set to the surface\n    const scenes: Lookup<BasicSurfaceSceneOptions> = {};\n\n    // Now loop through all of the generated views and initializers and generate the scenes we wil use in our\n    // basic surface. There will be a scene per view to simplify complexity and since the configuration for the views\n    // does not involve multi-view per group of layers.\n    for (let i = 0, iMax = viewsAndLayers.length; i < iMax; ++i) {\n      const [view, layers] = viewsAndLayers[i];\n\n      const scene: BasicSurfaceSceneOptions = {\n        layers: layers,\n        views: {\n          [view.key]: view,\n        },\n      };\n\n      setProp(scenes, scene, view.key.split(\".\"));\n    }\n\n    // Apply the generated scenes\n    this.scenes = scenes;\n    // Apply the discovered event managers\n    eventManagers.forEach((manager, i) => {\n      this.eventManagers[i] = manager;\n    });\n  }\n\n  /**\n   * Generates view initializers based on the layer initializers passed in. Each layer initializer has it's own type\n   * of required view type to render the layer appropriately.\n   */\n  private createViewInitializers(\n    keys: string[],\n    layer: LayerInitializer[],\n    view: QuickView\n  ): [ViewInitializer<IViewProps>, LayerInitializer[]][] {\n    const organizeByClass = new Map<ViewDefaults, LayerInitializer[]>();\n    const errored = new Set();\n\n    // First take all of the initializers and organize them by layer class. Each class type will have it's own potential ViewClass type\n    for (let i = 0, iMax = layer.length; i < iMax; ++i) {\n      const layerInit = layer[i];\n      const layerClass = layerInit.init[0];\n      const viewDefaults = QuickSurface.layerViewMap.get(layerClass);\n\n      // We MUST have a mapped View object in order to be able to render the layer type.\n      if (!viewDefaults) {\n        // Only display the error once for each layer class\n        if (errored.has(layerClass)) {\n          console.warn(\n            `Quick Surface could not determine a View type appropriate for the inferred layer type.`,\n            \"All elements that require this layer type will not be rendered.\",\n            \"Layer:\",\n            layerClass\n          );\n          errored.add(layerClass);\n        }\n        continue;\n      }\n\n      // Now organize each layer to the view it should be a part of\n      let layers = organizeByClass.get(viewDefaults);\n\n      if (!layers) {\n        layers = [];\n        organizeByClass.set(viewDefaults, layers);\n      }\n\n      layers.push(layerInit);\n    }\n\n    // Now that each layer is appropriately organized by the views it will be associated with, we can generate the\n    // needed view initializers\n    const out: [ViewInitializer<IViewProps>, LayerInitializer[]][] = [];\n    // This is an identifier to ensure our view's have unique keys\n    let viewId = -1;\n\n    organizeByClass.forEach((layers, viewDefaults) => {\n      let key = keys;\n\n      if (organizeByClass.size > 1) {\n        key = key.concat(`${++viewId}`);\n      }\n\n      const viewInit = createView(viewDefaults.type, {\n        ...viewDefaults.defaults,\n        key: key.join(\".\"),\n        camera:\n          view.camera ||\n          new ReferenceCamera2D({\n            base: this.defaultCamera,\n          }),\n        viewport: view.viewport,\n      });\n\n      out.push([viewInit, layers]);\n    });\n\n    return out;\n  }\n\n  /**\n   * Frees all GPU memory and resources used by this Surface.\n   */\n  destroy = () => {\n    // Make sure the base surface is destroyed and all WebGL resources are freed.\n    if (this.base) {\n      this.base.destroy();\n      delete this.base;\n    }\n\n    // Ensure our event loop is halted\n    if (this.eventProcessingLoopId) {\n      stopAnimationLoop(this.eventProcessingLoopId);\n    }\n  };\n\n  /**\n   * Tells the surface to resize to the container if it's not fitted currently.\n   */\n  fitContainer(preventRedraw?: boolean) {\n    if (this.base) {\n      this.base.fitContainer(preventRedraw);\n    }\n  }\n\n  /**\n   * This checks all of our created QueuedHandlers for events that have queued up for processing. This will process\n   * all of those events and pass them onto the proper callback that was assigned in the options for this surface.\n   */\n  handleEvents = () => {\n    // First handle all mouse events. Mouse and touch events must be handled separately as the structure of each event\n    // is very different.\n    for (let i = 0, iMax = this.mouseQueuedHandlers.length; i < iMax; ++i) {\n      const queuedHandler = this.mouseQueuedHandlers[i];\n      // Get all of the events that were picked up for the handler\n      const allEvents: [IPickInfo<Instance>][] = queuedHandler.process();\n      if (allEvents.length === 0) continue;\n      // Since we know this was a mouse event we can create a condensed version of all the events by simply using one\n      // of the info objects metrics and then aggregate all instances interacted with\n      const outInfo = Object.assign({}, allEvents[0][0]);\n\n      // Add in all of the instances from all of the events\n      for (let k = 1, kMax = allEvents.length; k < kMax; ++k) {\n        const [info] = allEvents[k];\n        outInfo.instances.splice(\n          outInfo.instances.length,\n          0,\n          ...info.instances\n        );\n      }\n\n      // Broadcast the event to the handler passed into QuickSurface options\n      queuedHandler.baseHandler(outInfo);\n    }\n\n    // Next handle all touch events. Mouse and touch events must be handled separately as the structure of each event\n    // is very different.\n    for (let i = 0, iMax = this.touchQueuedHandlers.length; i < iMax; ++i) {\n      const queuedHandler = this.touchQueuedHandlers[i];\n      // Get all of the events that were picked up for the handler\n      const allEvents: [IPickInfo<Instance>][] = queuedHandler.process();\n      if (allEvents.length === 0) continue;\n      // Since we know this was a mouse event we can create a condensed version of all the events by simply using one\n      // of the info objects metrics and then aggregate all instances interacted with\n      const outInfo = Object.assign({}, allEvents[0][0]);\n\n      // Add in all of the instances from all of the events\n      for (let k = 1, kMax = allEvents.length; k < kMax; ++k) {\n        const [info] = allEvents[k];\n        outInfo.instances.splice(\n          outInfo.instances.length,\n          0,\n          ...info.instances\n        );\n      }\n\n      // Broadcast the event to the handler passed into QuickSurface options\n      queuedHandler.baseHandler(outInfo);\n    }\n  };\n\n  /**\n   * Initializes all elements for the surface\n   */\n  async init() {\n    // If the base is established, then this is initialized\n    if (this.base) return;\n\n    // Analyze the input data and generate the providers to model the input.\n    this.createProvidersAndLayers();\n    // After the layer initializers are created, we can analyze our event handlers specified and apply the appropriate\n    // events to the initializers\n    this.createEventHandlerQueues();\n    // Generate the scenes\n    this.createScenesAndViews();\n    // We make our default font mimic the inherited font of the container to further simplify configuration.\n    const style = getComputedStyle(this.options.container);\n    const defaultFont = QuickSurface.defaultResources\n      .defaultFont as IFontResourceOptions;\n    defaultFont.fontSource.family = style.fontFamily;\n\n    // Create the surface to work with\n    this.base = new BasicSurface({\n      container: this.options.container,\n      providers: this.data,\n      resources: QuickSurface.defaultResources,\n      cameras: {},\n      handlesWheelEvents: true,\n      rendererOptions: {\n        alpha: false,\n        antialias: true,\n        ...this.options.rendererOptions,\n      },\n      eventManagers: () => this.eventManagers,\n      scenes: () => this.scenes,\n      onNoWebGL: () => this.options.onNoWebGL?.(),\n    });\n\n    // Wait for the base to be prepared\n    await this.base.ready;\n    // Wait on all of our refs for completion of initial adding\n    const refs = lookupValues(isLayerRef, this.refs);\n    const completes = refs\n      .map((ref) => ref.easing?.complete())\n      .filter(isDefined);\n    await Promise.all(completes);\n\n    this._ready.resolve();\n  }\n}\n","/**\n * Export all items you wish your library bundle to export and have available via:\n * import { Things } from 'your-library';\n *\n * Import any items the library bundle may need but does not need to make public.\n */\nexport * from \"./types\";\nexport * from \"./constants\";\nexport * from \"./surface\";\nimport \"./config\";\n","export const CONSTANTS_NOOP = () => {\n  /** NOOP */\n};\n","export * from \"./quick-surface\";\n","import { Lookup } from \"deltav\";\n\n/**\n * Retrieve a property from an object using a list of keys\n */\nexport function deleteProp<T>(\n  target: Lookup<T | undefined>,\n  keys: string[]\n): boolean {\n  let current: Lookup<T | undefined> | T | undefined = target;\n  if (current === void 0) return current;\n\n  // Loop through the keys to select the appropriate object within the object\n  for (let i = 0, iMax = keys.length - 1; i < iMax; ++i) {\n    const key = keys[i];\n    // We caste to any as we're doing a loop into an object and there isn't a really good way to have deep diving type\n    current = (current as any)[key];\n    // If we hit a null or undefined object prematurely, then our key path is invalid for this object, thus no deletion\n    if (current === void 0 || current === null) return false;\n  }\n\n  // Use the last key as the target item for deletion\n  if (current === void 0 || current === null) return false;\n  return delete (current as any)[keys[keys.length - 1]];\n}\n","import { Lookup } from \"deltav\";\nimport { DeepMap } from \"../types\";\n\n/**\n * Retrieve a property from an object using a list of keys\n */\nexport function getProp<T>(\n  target: Lookup<T | undefined> | DeepMap<any, any, T | undefined>,\n  keys: string[]\n): Lookup<T | undefined> | T | undefined {\n  let current: Lookup<T | undefined> | T | undefined = target;\n  if (current === void 0) return current;\n\n  for (let i = 0, iMax = keys.length; i < iMax; ++i) {\n    const key = keys[i];\n    // We caste to any as we're doing a loop into an object and there isn't a really good way to have deep diving\n    current = (current as any)[key];\n    if (current === void 0 || current === null) return;\n  }\n\n  return current;\n}\n","import { Lookup } from \"deltav\";\n\n/**\n * This gets all of the values of a Lookup\n */\nexport function lookupValues<T>(\n  check: (val?: Lookup<T | undefined> | T) => val is T,\n  lookup: Lookup<T | undefined>\n): T[] {\n  const out: T[] = [];\n  const toProcess = Object.values(lookup);\n\n  for (let index = 0; index < toProcess.length; ++index) {\n    const next = toProcess[index];\n\n    if (check(next)) {\n      out.push(next as T);\n    } else if (next !== void 0 && next !== null) {\n      toProcess.push(...Object.values(next));\n    }\n  }\n\n  return out;\n}\n","/**\n * This will return the class an object inherits or is an instance of and continue up the chain of inheritance until\n * a null value for the inherited class is found. This can be early exited by returning 'true' indicating the needed\n * inherited element is found.\n */\nexport function loopInheritance<T>(\n  obj: T,\n  callback: (base: Function | object) => boolean | void\n) {\n  let baseClass = Object.getPrototypeOf(obj);\n\n  while (baseClass !== null) {\n    const quit = callback(\n      baseClass.constructor ? baseClass.constructor : baseClass\n    );\n    if (quit) break;\n    baseClass = Object.getPrototypeOf(baseClass);\n  }\n}\n","import { Lookup } from \"deltav\";\nimport { DeepMap } from \"../types\";\n\n/**\n * This takes a lookup and maps all of it's values to another lookup with different values but with the same keys.\n */\nexport function mapLookupValues<\n  TInput,\n  TLookup extends Lookup<TInput>,\n  TOutput\n>(\n  label: string,\n  check: (value: TInput | TLookup) => value is TInput,\n  lookup: TLookup,\n  callback: (key: string[], value: TInput) => TOutput\n): DeepMap<TLookup, TInput, TOutput> {\n  const added = new Set();\n  // We have to initialize the output lookup as empty since we are building it with this method. Thus the needed\n  // casting.\n  const out: DeepMap<TLookup, TInput, TOutput> = {} as DeepMap<\n    TLookup,\n    TInput,\n    TOutput\n  >;\n\n  const toProcess = Object.keys(lookup).map<[string[], TInput | TLookup]>(\n    (key) => [[key], (lookup as any)[key]]\n  );\n\n  for (let index = 0; index < toProcess.length; ++index) {\n    const next: [string[], TInput | TLookup] = toProcess[index];\n\n    if (check(next[1])) {\n      // Get the object that we are mapping to using the callback provided.\n      const mappedObject = callback(next[0], next[1]);\n      // We will now use the stored keys to drill down into the output object to provide the outputted mapped object\n      // and ensure all keys exist in the object for the drilldown to thus complete the mapping.\n      const keys = next[0];\n      // Can waste a lot of time trying to get this type correct. Essentially we are making a reference to the next\n      // level of key that we are accessing. This should be keys that match the 'lookup' parameter's lookup keys and\n      // should be applied to the output.\n      let nextRef: any = out;\n\n      for (let i = 0, iMax = keys.length; i < iMax; ++i) {\n        const accessKey = keys[i];\n\n        // If we are at the last key, we should apply the object we pulled from the mapping callback\n        if (i === keys.length - 1) {\n          nextRef[accessKey] = mappedObject;\n        }\n\n        // If we are at a key that will have more keys that need processing, then we just ensure an object is present\n        // for the given key and we use that keys object as our next step in drilling down the object lookups.\n        else {\n          if (!nextRef[accessKey]) {\n            nextRef[accessKey] = {};\n          }\n\n          nextRef = nextRef[accessKey];\n        }\n      }\n    } else {\n      let error = false;\n\n      Object.keys(next[1]).forEach((key) => {\n        const value = (next[1] as any)[key];\n\n        if (!added.has(value)) {\n          toProcess.push([next[0].concat(key), value]);\n          added.add(value);\n        } else {\n          error = true;\n          console.warn(\"Invalid lookup for mapping values detected:\", label);\n        }\n      });\n\n      if (error) break;\n    }\n  }\n\n  return out;\n}\n","/**\n * This is a special handler manager that consolidates several similar handlers to output to a single handler\n */\nexport class QueuedHandler {\n  /** This stores all handler's input arguments so they can be  */\n  private queue: any[] = [];\n  /** This is the intended output handler the queued handler is funneling all events to */\n  baseHandler: Function;\n\n  constructor(base: Function) {\n    this.baseHandler = base;\n  }\n\n  /**\n   * This generates a handler that will work with this queue and have it's results aggregated rather than broadcast\n   * immediately.\n   */\n  createHandler() {\n    return (...args: any[]) => {\n      this.queue.push(args);\n    };\n  }\n\n  /**\n   * Provides all of the queued results since last process request.\n   */\n  process() {\n    const out = this.queue;\n    this.queue = [];\n    return out;\n  }\n}\n","import { Lookup } from \"deltav\";\n\n/**\n * Retrieve a property from an object using a list of keys\n */\nexport function setProp<T>(target: Lookup<T>, value: T, keys: string[]) {\n  let current: Lookup<T> | T = target;\n\n  for (let i = 0, iMax = keys.length - 1; i < iMax; ++i) {\n    const key = keys[i];\n    // We caste to any as we're doing a loop into an object and there isn't a really good way to have deep diving\n    current = (current as any)[key] = (current as any)[key] || {};\n  }\n\n  if (keys.length > 0) {\n    (current as any)[keys[keys.length - 1]] = value;\n    return true;\n  }\n\n  return false;\n}\n","import {\n  ArcInstance,\n  ArcLayer,\n  ArcScaleType,\n  AutoEasingMethod,\n  Camera,\n  Camera2D,\n  CircleInstance,\n  CircleLayer,\n  EdgeInstance,\n  EdgeLayer,\n  EdgeType,\n  IArcLayerProps,\n  ICircleLayerProps,\n  IEdgeLayerProps,\n  IImageLayerProps,\n  ILabelLayerProps,\n  ImageInstance,\n  ImageLayer,\n  InstanceProvider,\n  IRingLayerProps,\n  ITextAreaLayerProps,\n  LabelInstance,\n  LabelLayer,\n  RectangleLayer,\n  ReferenceCamera2D,\n  RingInstance,\n  RingLayer,\n  ScaleMode,\n  TextAreaInstance,\n  TextAreaLayer,\n  View2D,\n} from \"deltav\";\nimport { QuickSurface } from \"./surface/quick-surface\";\n\n// Set up Layer type to Resource mapping\n\nQuickSurface.layerResourceMap.set(ImageLayer, { resourceKey: \"defaultAtlas\" });\n\nQuickSurface.layerResourceMap.set(LabelLayer, { resourceKey: \"defaultFont\" });\n\nQuickSurface.layerResourceMap.set(TextAreaLayer, {\n  resourceKey: \"defaultFont\",\n});\n\n// Set up Instance to Layer compatibility\n\nQuickSurface.instanceLayerMap.set(CircleInstance, {\n  type: CircleLayer,\n  defaults: () =>\n    ({\n      animate: {\n        center: AutoEasingMethod.easeInOutCubic(500),\n        radius: AutoEasingMethod.easeBackOut(200),\n      },\n      data: new InstanceProvider(),\n      key: \"\",\n      streamChanges: { count: 1000 },\n      usePoints: true,\n    } as ICircleLayerProps<CircleInstance>),\n});\n\nQuickSurface.instanceLayerMap.set(EdgeInstance, {\n  type: EdgeLayer,\n  defaults: (instance) => {\n    const edge = instance as EdgeInstance;\n\n    return {\n      type:\n        edge.control.length > 1\n          ? EdgeType.BEZIER2\n          : edge.control.length > 0\n          ? EdgeType.BEZIER\n          : EdgeType.LINE,\n      animate: {\n        start: AutoEasingMethod.easeInOutCubic(500),\n        end: AutoEasingMethod.easeInOutCubic(500),\n      },\n      data: new InstanceProvider(),\n      key: \"\",\n      streamChanges: { count: 1000 },\n    } as IEdgeLayerProps<EdgeInstance>;\n  },\n});\n\nQuickSurface.instanceLayerMap.set(ArcInstance, {\n  type: ArcLayer,\n  defaults: () =>\n    ({\n      scaleType: ArcScaleType.NONE,\n      animate: {\n        angle: AutoEasingMethod.easeOutCubic(500),\n        angleOffset: AutoEasingMethod.easeOutCubic(500),\n        radius: AutoEasingMethod.easeOutCubic(500),\n      },\n      data: new InstanceProvider(),\n      key: \"\",\n      streamChanges: { count: 1000 },\n    } as IArcLayerProps<ArcInstance>),\n});\n\nQuickSurface.instanceLayerMap.set(RingInstance, {\n  type: RingLayer,\n  defaults: () =>\n    ({\n      data: new InstanceProvider(),\n      key: \"\",\n      animate: {\n        center: AutoEasingMethod.easeOutCubic(500),\n        radius: AutoEasingMethod.easeOutElastic(500),\n      },\n      streamChanges: { count: 1000 },\n    } as IRingLayerProps<RingInstance>),\n});\n\nQuickSurface.instanceLayerMap.set(LabelInstance, {\n  type: LabelLayer,\n  defaults: () =>\n    ({\n      animate: {\n        origin: AutoEasingMethod.easeOutCubic(500),\n        color: AutoEasingMethod.easeOutCubic(500),\n      },\n      data: new InstanceProvider(),\n      key: \"\",\n      resourceKey: \"\",\n      scaleMode: ScaleMode.BOUND_MAX,\n      truncation: \"...\",\n      streamChanges: { count: 1000 },\n    } as ILabelLayerProps<LabelInstance>),\n});\n\nQuickSurface.instanceLayerMap.set(TextAreaInstance, {\n  type: TextAreaLayer,\n  defaults: () =>\n    ({\n      data: new InstanceProvider(),\n      key: \"\",\n      resourceKey: \"\",\n      scaleMode: ScaleMode.BOUND_MAX,\n      truncation: \"...\",\n      streamChanges: { count: 1000 },\n    } as ITextAreaLayerProps<LabelInstance>),\n});\n\nQuickSurface.instanceLayerMap.set(ImageInstance, {\n  type: ImageLayer,\n  defaults: () =>\n    ({\n      data: new InstanceProvider(),\n      key: \"\",\n      atlas: \"\",\n      rasterizationScale: 1,\n      streamChanges: { count: 1000 },\n    } as IImageLayerProps<ImageInstance>),\n});\n\n// Set up Layer to View compatibility mapping\n\nconst view2DDefaults = {\n  type: View2D,\n  defaults: {\n    viewport: { left: 0, right: 0, top: 0, bottom: 0 },\n    clearFlags: [],\n    key: \"\",\n    camera: new Camera2D(),\n  },\n};\n\nQuickSurface.layerViewMap.set(CircleLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(RingLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(ArcLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(LabelLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(TextAreaLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(EdgeLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(RectangleLayer, view2DDefaults);\nQuickSurface.layerViewMap.set(ImageLayer, view2DDefaults);\n\n// Set up camera to camera reference mapping\n\nQuickSurface.cameraReferenceMap.set(Camera, (camera) => camera);\n\nQuickSurface.cameraReferenceMap.set(\n  Camera2D,\n  (camera) =>\n    new ReferenceCamera2D({\n      base: camera as Camera2D,\n    })\n);\n"],"sourceRoot":""}